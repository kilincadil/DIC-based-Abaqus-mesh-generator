"""
@author: akilinc

This script generates a mesh and inserts material properties into an Abaqus input file. It processes node, element, and element set data for an existing pre-generated mesh. 
The mesh is scaled to match the region of interest (ROI) with the sample, sections are added, and material properties are applied based on data derived from digital image correlation (DIC). 
The displacement and stress fields are obtained from optical microstructure images and mapped to the mesh.
The displacement and stress fields for this simulation are derived from segmented optical microstructure images of size 3100x3600 pixels. The stress (yielding and hardening) 
data at each pixel is obtained using the approach described in Qi et al. (2025). The material model used for this process follows Ludwik's material law, which relates stress 
to strain in a plastic deformation context. The field data is first mapped to the grain-twin scale, where each grain is associated with a dictionary of material properties. 
This data is then used to assign material properties to the respective mesh elements.  The 2D mesh is generated using CRISTALX, a tool developed by Zolt√°n Csati for creating 
high-quality meshes of crystalline materials. This mesh is used for simulating the mechanical behavior of the material under stress.
The boundary conditions for the mesh are directly mapped from the displacement fields generated by DIC, ensuring that the displacement values at each node of 
the mesh match the corresponding displacement values from the DIC measurements.

Csati, Z et al. (2021). CRISTALX. 
Hu, Q., et al. (2025).

"""

import numpy as np
from load import ArrayLoader
from read_elsets import AbaqusInputReader


class MeshCreator:
    """
    A class to create an Abaqus input file from the mesh data (nodes, elements, and element sets).
    
    Attributes:
        file_path (str): Path to the Abaqus input file to be created.
        nodes (list): List of nodes (node_id, x, y).
        elements (list): List of elements (element_id, node1, node2, node3).
        elsets (dict): Dictionary of element sets.
        scale_factor (float): Scale factor to scale the node coordinates.
        x_max (float): Maximum x-coordinate in the scaled mesh.
        y_max (float): Maximum y-coordinate in the scaled mesh.
    """
    def __init__(self, file_path, nodes, elements, elsets, scale_factor):
        self.file_path = file_path
        self.nodes = nodes
        self.elements = elements
        self.elsets = elsets
        self.scale_factor = scale_factor
        self.x_max = max(x for _, x, _ in nodes) * scale_factor
        self.y_max = max(y for _, _, y in nodes) * scale_factor

    def create_input_file(self):
        """
        Creates an Abaqus input file with the mesh data, including nodes, elements, and element sets.
        """
        with open(self.file_path, 'w') as f:
            # Scale the nodes by the scale factor
            scaled_nodes = [(node_id, x * self.scale_factor, y * self.scale_factor) for node_id, x, y in self.nodes]
            X_np, Y_np = np.array([x for _, x, _ in scaled_nodes]), np.array([y for _, _, y in scaled_nodes])
            node_ids = np.array([node_id for node_id, _, _ in scaled_nodes])
            node_data = np.stack([node_ids.ravel(), X_np.ravel(), Y_np.ravel()], axis=-1)

            def filter_nodes(condition):
                indices = np.where(condition)[0]
                return node_data[indices]

            # Filter nodes for boundaries
            bottom_nodes = filter_nodes(Y_np.ravel() == 0)
            top_nodes = filter_nodes(Y_np.ravel() == self.y_max)
            left_nodes = filter_nodes(X_np.ravel() == 0)
            right_nodes = filter_nodes(X_np.ravel() == self.x_max)

            # Writing to the file
            f.write("*Heading\n")
            f.write("** PARTS\n")
            f.write("*Part, name=PART-1\n")
            f.write("*NODE\n")
            for node_id, x, y in scaled_nodes:
                f.write("{}, {}, {}\n".format(node_id, x, y))
            f.write("*Element, type=CPS3\n")
            for element_id, node1, node2, node3 in self.elements:
                f.write("{}, {}, {}, {}\n".format(element_id, node1, node2, node3))

            # Write element sets and sections
            for set_id, elements in self.elsets.items():
                ID = set_id.split('_')[1]
                f.write("*Elset, elset={}\n".format(set_id))
                for i in range(0, len(elements), 16):
                    chunk = elements[i:i + 16]
                    elements_line = ", ".join(map(str, chunk))
                    f.write("{}\n".format(elements_line))
                f.write("*Solid Section, elset={}, material=Material-{}\n".format(set_id, ID))
                f.write("2.,\n")

            # Write assembly data
            f.write("*End Part\n")
            f.write("*Assembly, name=Assembly\n")
            f.write("*Instance, name=PART-1-1, part=PART-1\n")
            f.write("*End Instance\n")

            # Write node sets for boundaries
            for node_id, _, _ in bottom_nodes:
                f.write("*Nset, nset=NODEBOTTOM{}, instance=PART-1-1\n".format(int(node_id)))
                f.write("{}\n".format(int(node_id)))
            for node_id, _, _ in left_nodes:
                f.write("*Nset, nset=NODELEFT{}, instance=PART-1-1\n".format(int(node_id)))
                f.write("{}\n".format(int(node_id)))
            for node_id, _, _ in right_nodes:
                f.write("*Nset, nset=NODERIGHT{}, instance=PART-1-1\n".format(int(node_id)))
                f.write("{}\n".format(int(node_id)))
            for node_id, _, _ in top_nodes:
                f.write("*Nset, nset=NODETOP{}, instance=PART-1-1\n".format(int(node_id)))
                f.write("{}\n".format(int(node_id)))

            f.write("*End Assembly\n")

        print(f"Mesh created successfully at: {self.file_path}")


class MaterialInserter:
    """
    A class to insert material data and boundary conditions into an Abaqus input file.

    Attributes:
        file_path (str): Path to the Abaqus input file to insert data.
        displacement_array_y (numpy.ndarray): Array of displacement values in the y-direction.
        displacement_array_x (numpy.ndarray): Array of displacement values in the x-direction.
        nodes (list): List of nodes (node_id, x, y).
    """
    def __init__(self, file_path, displacement_array_y, displacement_array_x, nodes):
        self.file_path = file_path
        self.displacement_array_y = displacement_array_y
        self.displacement_array_x = displacement_array_x
        self.nodes = nodes
        self.scale_factor = 1.84  # Scale factor for node coordinates
        self.x_max = max(x for _, x, _ in nodes) * self.scale_factor
        self.y_max = max(y for _, _, y in nodes) * self.scale_factor

    def clamp(self, value, min_value, max_value):
        """Clamps the value between the min_value and max_value."""
        return max(min_value, min(value, max_value))

    def insert_material_data(self, stress_flow):
        """
        Inserts material data (elastic and plastic properties) and boundary conditions into the Abaqus input file.
        
        Parameters:
            stress_flow (dict): A dictionary containing mean stress values for each grain.
        """
        pixel_size = 1.84  # Conversion factor for pixel size to actual units
        scaled_nodes = [(node_id, x * self.scale_factor, y * self.scale_factor) for node_id, x, y in self.nodes]
        X_np, Y_np = np.array([x for _, x, _ in scaled_nodes]), np.array([y for _, _, y in scaled_nodes])
        node_ids = np.array([node_id for node_id, _, _ in scaled_nodes])
        node_data = np.stack([node_ids.ravel(), X_np.ravel(), Y_np.ravel()], axis=-1)

        def filter_nodes(condition):
            indices = np.where(condition)[0]
            return node_data[indices]

        # Filter boundary nodes
        bottom_nodes = filter_nodes(Y_np.ravel() == 0)
        top_nodes = filter_nodes(Y_np.ravel() == self.y_max)
        left_nodes = filter_nodes(X_np.ravel() == 0)
        right_nodes = filter_nodes(X_np.ravel() == self.x_max)

        with open(self.file_path, 'a') as f:
            # Write material data
            E_p = np.linspace(0.0, 0.005, 20)
            for set_id, mean_stresses in stress_flow.items():
                ID = set_id.split('_')[1]
                f.write("** MATERIALS\n")
                f.write(f"*Material, name=Material-{ID}\n")
                f.write("*Elastic\n")
                f.write("205000, 0.25\n")
                f.write("*Plastic\n")
                for k, stress_value in enumerate(mean_stresses):
                    f.write(f"{stress_value}, {E_p[k]}\n")

            # Write step data
            f.write("** STEP: Step-1\n")
            f.write("*Step, name=Step-1, nlgeom=NO\n")
            f.write("*Static\n")
            f.write("0.001, 1., 1e-06, 0.1\n")

            # Write boundary conditions for all sides
            def write_boundary_conditions(nodes, direction):
                for node_id, x, y in nodes:
                    x_pixel = self.clamp(int(round(x * 1000 / pixel_size)), 0, self.displacement_array_y.shape[0] - 1)
                    y_pixel = self.clamp(int(round(y * 1000 / pixel_size)), 0, self.displacement_array_y.shape[1] - 1)
                    displacement_y = self.displacement_array_y[x_pixel, y_pixel]
                    displacement_x = self.displacement_array_x[x_pixel, y_pixel]
                    f.write(f"** Name: {direction}{node_id} Type: Displacement/Rotation\n")
                    f.write("*Boundary\n")
                    f.write(f"{direction}{node_id}, 2, 2, {float(displacement_y)}\n")
                    f.write(f"{direction}{node_id}, 1, 1, {float(displacement_x)}\n")

            # Write boundary conditions for each side
            write_boundary_conditions(bottom_nodes, 'NODEBOTTOM')
            write_boundary_conditions(top_nodes, 'NODETOP')
            write_boundary_conditions(left_nodes, 'NODELEFT')
            write_boundary_conditions(right_nodes, 'NODERIGHT')

            # Write output requests
            f.write("** OUTPUT REQUESTS\n")
            f.write("*Restart, write, frequency=0\n")
            f.write("*Output, field\n")
            f.write("*Node Output\n")
            f.write("RF, U\n")
            f.write("*Element Output, directions=YES\n")
            f.write("E, PE, PEEQ, PEMAG, S\n")
            f.write("*Output, history, variable=PRESELECT\n")
            f.write("*End Step\n")

        print(f"Material data inserted successfully into: {self.file_path}")


"""# How it is used:
    
# Loading data
loader = ArrayLoader('path_to_stress_pixel_fields')
stress_values_pixel = loader.load()
array = np.load('path_to_stress_mean_assigned_to_grains_dicts', allow_pickle=True)
stress_mean_original = {key: tuple(array[key]) for key in array}
displacement_y = np.load('path_to_U_disp_U_mm')
displacement_x = np.load('path_to_V_disp') * 0.00184

# Reading mesh data
input_file_path = 'path_to_inp_file'
reader = AbaqusInputReader(input_file_path)
reader.read_nodes()
reader.read_elements()
reader.read_elsets()
nodes = reader.get_nodes()
elements = reader.get_elements()
elsets = reader.get_elsets()

# File path for the new Abaqus input file
file_path = 'path_to_new_inp_file'

# Create mesh and insert material data
scale_factor = 1.84
create_mesh = MeshCreator(file_path, nodes, elements, elsets, scale_factor)
create_mesh.create_input_file()

insert_data = MaterialInserter(file_path, displacement_y, displacement_x, nodes)
insert_data.insert_material_data(stress_mean_original)
"""